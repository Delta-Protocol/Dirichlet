- file Connect bug: shift with computed lhs miscalculated
- allow unequal sized numbers, e.g. when adding
- add allocator to radix32-integer
- process both roots during a single pass
- combine small factors when sieving into a single pattern

- add "right justify" method to IntegerMath

- try log(2 * x * sqrt(n)) as the cutoff: http://www.crypto-world.com/documents/contini_siqs.pdf
- convert to "round" instead of "cieling" for LogScale
- try sieving for 2 with a large number
- port multiplier code from msieve

- don't sieve for factors of multiplier (investigate first)
- for q[l], polynomial(x) | q[l] iff x = -c (2 b)^-1 mod q[l]
- fix ModularSquareRoot mod 2 if value is even, more generally if value mod modulus == 0

f(0) = -1
f(-1) = 1
f(1) = 1

f(x) = a x^2 + b x + c

f(0) = -1 = c
f(-1) = 1 = a - b + c
f(1) = 1 = a + b + c

c = -1

a - b - 1 = 1
a + b - 1 = 1

a - b = 2
a + b = 2

2 a = 4
a = 2
b = 0

f(x) = 2 x^2 - 1

f(x) = (ax + b)^2 - n

- merge add relation and create relation
- write integer mod/pow

a * b % n

         u1    u0
         v1    v0
-----------------
      u1*v0 u0*v0
u1*v1 u0*v1


- add integer reducer
- remove check from Montgomery for Montgomery32

b ^ (u1 * w + u0)

b ^ (u1 * w) * b ^ u0

b ^ w ^ u1 * b ^ u0

(2 ^ 64) ^ u1 * 2 ^ u0

- re-evaluate PPRS parameters, e.g. try increasing factor base size
- reuse PPRS infrastructure for PRS

a % d = a % (2^s dOdd) = a - (a / d) * d = a - (a / 2^s  2^s / dOdd dOdd

GCD(2^s, dOdd) = 1

if dOdd = 1:

a % d = a & ~(2^s - 1)

if d = 6, s = 1, dOdd = 3:

0 % 2 = 0, 0 % 3 = 0, 0 % 6 = 0
1 % 2 = 1, 1 % 3 = 1, 1 % 6 = 1
2 % 2 = 0, 2 % 3 = 2, 2 % 6 = 2
3 % 2 = 1, 3 % 3 = 0, 3 % 6 = 3
4 % 2 = 0, 4 % 3 = 1, 4 % 6 = 4
5 % 2 = 1, 5 % 3 = 2, 5 % 6 = 5

if a = 2^s aOdd and aOdd % 2 == 1:

a ^ e % 2^n = (2^s aOdd) ^ e % 2^n = (aOdd ^ e % 2^n) ^ 2^s % 2^n

result = aOdd ^ e % 2^n = aOdd ^ (e % 2^(n - 1)) % 2^n, and result % 2 == 1

a ^ e % 2^n = result ^ 2^s % 2^n = (result << s) & (2^n - 1)

u = (u1 * 2^n) + u0

u % d = (u1 % d) * (2^n % d) + u0 % d

modWord = 2^n % d

u % d = u1 % d * modWord + u0 % d

u / d = u1 * 2^n / d

u0 u1 * v0 v1 v2

u0 * v0  u0 * v1  u0 * v2
         u1 * v0  u1 * v1  u1 * v2

(a % b) / b mod 2^n = a * bInv mod 2^n

a divides b
a ?/ b
a ?!/ b
gcd(a, b)

a < b < c
floor division: //
move exact division to operations?
sqrt(2) should not equal 1

x = 14 (mod 13)

a = 2
b = 3
c = a b

floor(2/3).Type does the wrong thing, parsed as floor(divide(2,3).Type)

floor should return a rational

could add a modular factorial operator

(a + 1)^2 = a^2 + 2*a + 1

(m + 2^i)^2 <= n

m^2 + 2 m 2^i + 2^(2i) <= n
m^2 + 2m 2^i

Sum(1, i = 1 ... log n) = log n
Sum(1/i, i = 1 ... log n) = O(log log n)
Sum(1/i, i = 1 ... log n; isprime i) = O(log log log n)

[1 ... floor log n].Where(i => isprime i).Sum(i => 1/i)

add primorial to IntegerMath, add # primorial operator

need constants like pi

add trig functions, sin, cos, tan, etc.

add binomial coefficients

add gamma function

- Euler zeta function
- Euler product formula
- analytic continuation from Re(s) > 1 to Re(s) > 0
  - http://www.proofwiki.org/wiki/Analytic_Continuation_of_the_Riemann_Zeta_Function
  - Abel's lemma
  - reverse integration
  - collection of adjacent integrals
  - rewrite floor as variable less fractional part
  - solve former definite exactly assuming subset Re(s) > 1 for uniqueness
  - latter integral converges for all Re(s) > 0
- functional equation using gamma function extending to Re(s) < 0
  - http://www.proofwiki.org/wiki/Equivalence_of_Riemann_Zeta_Function_Definitions
- convert to entire function to eliminate pole
- expand to expression using zeros with the Weierstrass factorization theorem
  - http://en.wikipedia.org/wiki/Weierstrass_factorization_theorem
- Take the logrithmic derivative
  - http://en.wikipedia.org/wiki/Logarithmic_derivative

Assume there are a finite number of twin primes.
Then there is a largest pair of primes, p[max] and p[max] + 2.
For every prime p[i] larger than this pair, p[i] + 2 is composite.
Consider p[max] < p[i] < p[max]^2.
p[i] + 2 is divisible by a prime less than p[max].

4....
3x...
2x...
1xxx.
 1234

Sum(tau(n), n = [1,4)) = 3 + 1 + 1 = 5 = 2*Sum(floor(3.5/a), a = [1,2)) - isqrt(3.5)^2 = 2(3) - 1 = 5

9.........
8x........
7x........
6x........
5x........
4xx.......
3xx.......
2xxxx.....
1xxxxxxxx.
 123456789

Sum(tau(n), n = [1,9)) = 8 + 4 + 2*2 + 4 = 5 = 2*Sum(floor(8.5/a), a = [1,floor(sqrt(9))) - floor(sqrt(8.5))^2 = 2(8+4) - 4 = 20

2(floor(8.5/1) - 1 + floor(8.5/2) - 2) + sqrt(8.5)
2(8 - 1 + 4 - 2) + 2 = 2(7 + 2) + 2 = 2*9 + 2 = 20

sum(floor(y/a) - a, a = [2,floor(n^(1/2)))
sum(floor(y/2a) - a, a = [3,floor((n/2)^(1/2)))
sum(floor(y/3a) - a, a = [4,floor((n/3)^(1/2)))
...
sum(floor(y/floor(n^(1/3)) - a, a = [floor(n^(1/3)),floor((n/n^(1/3))^(1/2))))

sqrt(n) - 1 + sqrt(n)/sqrt(2) - 2 + sqrt(n)/sqrt(3) - 3 + ... + sqrt(n)/sqrt(i) - i
sqrtn(n) * (1 + 1/sqrt(2) + 1/sqrt(3) + ... + 1/sqrt(i)) - (1 + 2 + 3 + ... + i)
sqrt(n) * O(i^(1/2))
i = [1, floor(n^(1/3))]
sqrt(n) * sqrt(n^(1/3))
O(sqrt(n) * n^(1/6)) = O(n^(1/2+1/6)) = O(n^(2/3))

integral(1/sqrt(x), x=[1,i]) = integral(x^(-1/2)) = 2i^(1/2)

9/1 = 8, 9/2 = 4, 9/3 = 2, 9/4 = 1

Sum(Tau(n), n : n < x, 2^2 | n)
Sum(Tau(n), n = { 4, 8, 12, ... })

Tau(4) + Tau(8) + Tau(12) + ...

Tau(1)*Tau(4) + Tau(2)*Tau(4) + Tau(3)*Tau(4) + ...

Tau(4)(Tau(1) + Tau(2) + Tau(3) + ...)

1, 4, 9, 16, 25

(n + 1)^2 = n^2 + 2n + 1

