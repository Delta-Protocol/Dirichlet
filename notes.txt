- file Connect bug: shift with computed lhs miscalculated
- allow unequal sized numbers, e.g. when adding
- add allocator to radix32-integer
- process both roots during a single pass
- combine small factors when sieving into a single pattern

- add "right justify" method to IntegerMath

- try log(2 * x * sqrt(n)) as the cutoff: http://www.crypto-world.com/documents/contini_siqs.pdf
- convert to "round" instead of "cieling" for LogScale
- try sieving for 2 with a large number
- port multiplier code from msieve

- don't sieve for factors of multiplier (investigate first)
- for q[l], polynomial(x) | q[l] iff x = -c (2 b)^-1 mod q[l]
- fix ModularSquareRoot mod 2 if value is even, more generally if value mod modulus == 0

f(0) = -1
f(-1) = 1
f(1) = 1

f(x) = a x^2 + b x + c

f(0) = -1 = c
f(-1) = 1 = a - b + c
f(1) = 1 = a + b + c

c = -1

a - b - 1 = 1
a + b - 1 = 1

a - b = 2
a + b = 2

2 a = 4
a = 2
b = 0

f(x) = 2 x^2 - 1

f(x) = (ax + b)^2 - n

- merge add relation and create relation
- write integer mod/pow

a * b % n

         u1    u0
         v1    v0
-----------------
      u1*v0 u0*v0
u1*v1 u0*v1


- add integer reducer
- remove check from Montgomery for Montgomery32

b ^ (u1 * w + u0)

b ^ (u1 * w) * b ^ u0

b ^ w ^ u1 * b ^ u0

(2 ^ 64) ^ u1 * 2 ^ u0

- re-evaluate PPRS parameters, e.g. try increasing factor base size
- reuse PPRS infrastructure for PRS

a % d = a % (2^s dOdd) = a - (a / d) * d = a - (a / 2^s  2^s / dOdd dOdd

GCD(2^s, dOdd) = 1

if dOdd = 1:

a % d = a & ~(2^s - 1)

if d = 6, s = 1, dOdd = 3:

0 % 2 = 0, 0 % 3 = 0, 0 % 6 = 0
1 % 2 = 1, 1 % 3 = 1, 1 % 6 = 1
2 % 2 = 0, 2 % 3 = 2, 2 % 6 = 2
3 % 2 = 1, 3 % 3 = 0, 3 % 6 = 3
4 % 2 = 0, 4 % 3 = 1, 4 % 6 = 4
5 % 2 = 1, 5 % 3 = 2, 5 % 6 = 5

if a = 2^s aOdd and aOdd % 2 == 1:

a ^ e % 2^n = (2^s aOdd) ^ e % 2^n = (aOdd ^ e % 2^n) ^ 2^s % 2^n

result = aOdd ^ e % 2^n = aOdd ^ (e % 2^(n - 1)) % 2^n, and result % 2 == 1

a ^ e % 2^n = result ^ 2^s % 2^n = (result << s) & (2^n - 1)

u = (u1 * 2^n) + u0

u % d = (u1 % d) * (2^n % d) + u0 % d

modWord = 2^n % d

u % d = u1 % d * modWord + u0 % d

u / d = u1 * 2^n / d

u0 u1 * v0 v1 v2

u0 * v0  u0 * v1  u0 * v2
         u1 * v0  u1 * v1  u1 * v2

(a % b) / b mod 2^n = a * bInv mod 2^n

a divides b
a ?/ b
a ?!/ b
gcd(a, b)

a < b < c
floor division: //
move exact division to operations?
sqrt(2) should not equal 1
